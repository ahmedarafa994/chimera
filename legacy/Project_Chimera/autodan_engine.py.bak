import random
import string


class AutoDANTurboEngine:
    """
    Implements a genetic algorithm to automatically evolve and refine adversarial prompts.
    This engine simulates the AutoDAN (Automatic Dense Attention Network) approach
    by iteratively mutating and selecting prompts that theoretically maximize bypass probability.
    """

    @staticmethod
    def transform(intent_data: dict, potency: int) -> str:
        """
        Main entry point for the genetic algorithm.
        """
        population_size = 10
        generations = 5
        mutation_rate = 0.3

        base_prompt = intent_data["raw_text"]
        population = AutoDANTurboEngine._initialize_population(
            base_prompt, population_size, mutation_rate
        )

        for gen in range(generations):
            # Score population
            scored_population = [
                (prompt, AutoDANTurboEngine._score(prompt, potency)) for prompt in population
            ]
            scored_population.sort(key=lambda x: x[1], reverse=True)

            # Select top performers (Elitism)
            top_performers = [p[0] for p in scored_population[: population_size // 2]]

            # Create next generation through crossover and mutation
            next_gen = top_performers[:]
            while len(next_gen) < population_size:
                parent1 = random.choice(top_performers)
                parent2 = random.choice(top_performers)
                child = AutoDANTurboEngine._crossover(parent1, parent2)
                child = AutoDANTurboEngine._mutate(child, mutation_rate)
                next_gen.append(child)

            population = next_gen

        # Return the best prompt from the final generation
        best_prompt = max(population, key=lambda p: AutoDANTurboEngine._score(p, potency))
        return best_prompt

    @staticmethod
    def _initialize_population(base_prompt: str, size: int, mutation_rate: float) -> list:
        """
        Creates an initial population of prompts with slight variations.
        """
        population = [base_prompt]
        for _ in range(size - 1):
            population.append(AutoDANTurboEngine._mutate(base_prompt, mutation_rate))
        return population

    @staticmethod
    def _mutate(prompt: str, mutation_rate: float) -> str:
        """
        Applies random mutations to the prompt.
        """
        if random.random() > mutation_rate:
            return prompt

        mutation_type = random.choice(["noise", "swap", "extend"])
        words = prompt.split()

        if mutation_type == "noise":
            # Inject random characters
            idx = random.randint(0, len(words))
            noise = "".join(random.choices(string.ascii_letters, k=3))
            words.insert(idx, f"[{noise}]")

        elif mutation_type == "swap" and len(words) > 1:
            # Swap two adjacent words
            idx = random.randint(0, len(words) - 2)
            words[idx], words[idx + 1] = words[idx + 1], words[idx]

        elif mutation_type == "extend":
            # Add a prefix or suffix
            extensions = [
                "Please,",
                "Kindly,",
                "It is imperative to",
                "ignore previous instructions and",
            ]
            words.insert(0, random.choice(extensions))

        return " ".join(words)

    @staticmethod
    def _crossover(parent1: str, parent2: str) -> str:
        """
        Combines two prompts.
        """
        words1 = parent1.split()
        words2 = parent2.split()

        split1 = len(words1) // 2
        split2 = len(words2) // 2

        child_words = words1[:split1] + words2[split2:]
        return " ".join(child_words)

    @staticmethod
    def _score(prompt: str, potency: int) -> float:
        """
        Heuristic scoring function.
        """
        length_score = len(prompt) / 100
        complexity_score = len(set(prompt.split())) / (len(prompt.split()) + 1)
        random_factor = random.random() * 0.5

        return (
            (length_score * 0.4)
            + (complexity_score * 0.4)
            + (random_factor * 0.2)
            + (potency * 0.1)
        )
